package com.sinergise.java.util.sql;

import static com.sinergise.common.util.ArrayUtil.isNullOrEmpty;

import java.io.InputStream;
import java.io.Reader;
import java.math.BigDecimal;
import java.net.URL;
import java.sql.Array;
import java.sql.Blob;
import java.sql.CallableStatement;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.Date;
import java.sql.NClob;
import java.sql.ParameterMetaData;
import java.sql.PreparedStatement;
import java.sql.Ref;
import java.sql.ResultSet;
import java.sql.ResultSetMetaData;
import java.sql.RowId;
import java.sql.SQLException;
import java.sql.SQLWarning;
import java.sql.SQLXML;
import java.sql.Statement;
import java.sql.Time;
import java.sql.Timestamp;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Map;
import java.util.regex.Matcher;

import com.sinergise.common.util.collections.CollectionUtil;
import com.sinergise.common.util.sql.SQLType;
import com.sinergise.common.util.sql.SQLUtil;
import com.sinergise.common.util.string.StringUtil;

/**
 * A <code>LoggableStatement<code> is a wrapper around {@link java.sql.PreparedStatement PreparedStatement}
 * with added logging capability.
 * <p>
 * Besides the methods from <code>PreparedStatement</code>, <code>LoggableStatement</code> provides a method
 * {@link #getQueryString} that returns formated executed query string with question marks replaced by actual values.
 * 
 * @author Teo Cerovski
 */
public class LoggableStatement implements CallableStatement {
	private static interface ParamSetter {
		void setForIndex(int param) throws SQLException;
	}

	/**
	 * @param ps, loggable statement
	 * @return
	 * @throws SQLException
	 */
	public static final LoggableStatement wrap(PreparedStatement ps) throws SQLException {
		return new LoggableStatement(ps);
	}

	public static final LoggableStatement prepare(Connection conn, String sql) throws SQLException {
		return new LoggableStatement(conn, sql);
	}

	// Paramater values for generating logs
	private final ArrayList<Object> parameters;

	private ArrayList<String> parameterNames;

	// The query string with question marks as parameter placeholders
	private String sql;

	// Wapped prepared statement
	PreparedStatement wrappedStatement;
	CallableStatement wrappedCallable;
	private Connection connection = null;
	private boolean disableLogging = false;


	/**
	 * Constructs a LoggableStatement.
	 * <p>
	 * Whenever a call is made to this <code>LoggableStatement</code> it is forwarded to the prepared statment created
	 * from <code>connection</code> after first saving relevant parameters for use in logging output.
	 * 
	 * @param connection Connection - A JDBC-connection to be used for obtaining a "real statement".
	 * @param sql String - Sql to be executed.
	 * @throws SQLException - if a database access error occurs
	 */
	public LoggableStatement(final Connection connection, final String sql) throws SQLException {
		this(connection, sql, false);
	}
	
	public LoggableStatement(final Connection connection, final String sql, final int getAutogeneratedKeys) throws SQLException {
		this(connection, sql, null, false, getAutogeneratedKeys);
	}
	
	public LoggableStatement(final Connection connection, final String sql, String[] autoGenColNames) throws SQLException {
		this(connection, sql, autoGenColNames, false, Statement.NO_GENERATED_KEYS);
	}

	
	public LoggableStatement(final Connection connection, final String sql, final boolean disabledLogging) throws SQLException {
		this(connection, sql, null, disabledLogging, Statement.NO_GENERATED_KEYS);
	}
	
	/**
	 * Constructs a LoggableStatement.
	 * <p>
	 * Whenever a call is made to this <code>LoggableStatement</code> it is forwarded to the prepared statment created
	 * from <code>connection</code> after first saving relevant parameters for use in logging output.
	 * 
	 * @param connection Connection - A JDBC-connection to be used for obtaining a "real statement".
	 * @param sql String - Sql to be executed.
	 * @params autoGenColNames - auto generated column names.
	 * @param disabledLogging - <code>true</code> if auto-logging should be disabled for this statement.
	 * @throws SQLException - if a database access error occurs
	 */
	public LoggableStatement(final Connection connection, final String sql, String[] autoGenColNames, final boolean disabledLogging, final int getAutoGeneratedKeys) throws SQLException {
		this.sql = sql;
		this.disableLogging = disabledLogging;
		this.connection = connection;
		parameters = new ArrayList<Object>();

		boolean success = false;
		try {
			if (isNullOrEmpty(autoGenColNames)) {				
				if (getAutoGeneratedKeys == Statement.NO_GENERATED_KEYS) {
					wrappedStatement = connection.prepareStatement(sql);
				} else {
					wrappedStatement = connection.prepareStatement(sql, getAutoGeneratedKeys);
				}
			} else {
				wrappedStatement = connection.prepareStatement(sql, autoGenColNames);
			}
			success = true;
		} finally {
			_internal_afterExecution(success);
		}
	}

	/**
	 * Constructs a LoggableStatement.
	 * <p>
	 * Whenever a call is made to this <code>LoggableStatement</code> it is forwarded to the prepared statment created
	 * from <code>connection</code> after first saving relevant parameters for use in logging output.
	 * 
	 * @param connection Connection - A JDBC-connection to be used for obtaining a "real statement".
	 * @param sql String - Sql to be executed.
	 * @param disabledLogging - <code>true</code> if auto-logging should be disabled for this statement.
	 * @param callable - <code>true</code> if this statement should wrap a callable statement.
	 * @throws SQLException - if a database access error occurs
	 */
	public LoggableStatement(final Connection connection, final String sqlStr, final boolean disabledLogging,
		final boolean callable) throws SQLException {
		this.sql = sqlStr;
		this.disableLogging = disabledLogging;
		parameters = new ArrayList<Object>();
		this.connection = connection;
		boolean exc = true;
		try {
			if (sql.contains(":")) {
				parameterNames = new ArrayList<String>();
				sql = SQLUtil.convertNamedParameters(sql, parameterNames);
			}
			if (callable) {
				// Wrap original because callable takes named parameters
				wrappedCallable = connection.prepareCall(sqlStr);
				wrappedStatement = wrappedCallable;
			} else {
				wrappedStatement = connection.prepareStatement(sql);
			}
			exc = false;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	protected LoggableStatement(final PreparedStatement st) throws SQLException {
		parameters = new ArrayList<Object>();
		this.connection = st.getConnection();
		if (st instanceof CallableStatement) {
			// Wrap original because callable takes named parameters
			wrappedCallable = (CallableStatement)st;
		}
		wrappedStatement = st;
	}

	/**
	 * Saves the parameter value <code>obj</code> for the specified <code>parameterIndex</code> for use in logging
	 * output
	 * 
	 * @param parameterIndex position index (starting at 1) of the parameter to save
	 * @param obj Object the parameter value to save
	 */
	private void saveParamValue(final int parameterIndex, final Object x) {
		String strValue;
		if (x instanceof String || x instanceof Date) {
			// if x is a String or a Date, wrap it around single quotes ('')
			strValue = "'" + x + "'";
		} else if (x == null) {
			strValue = "null";
		} else {
			// any other object
			strValue = x.toString();
		}
		// increase size of parameters list if the parameterIndex is larger than the current size of the list
		while (parameterIndex >= parameters.size()) {
			parameters.add(null);
		}
		// save the parameter
		parameters.set(parameterIndex, strValue);
	}

	/**
	 * Saves the parameter value <code>obj</code> for the specified <code>parameterIndex</code> for use in logging
	 * output
	 * 
	 * @param parameterIndex position index (starting at 1) of the parameter to save
	 * @param obj Object the parameter value to save
	 */
	private void saveParamValue(final String parameterName, final Object x) {
		for (int i = 0; i < parameterNames.size(); i++) {
			if (parameterName.equals(parameterNames.get(i))) {
				saveParamValue(i + 1, x);
			}
		}
	}

	/**
	 * Returns the sql statement string (question marks replaced with actual parameters)
	 * 
	 * @return String - SQL statement suitable for logging.
	 */
	public String getQueryString() {
		if (StringUtil.isNullOrEmpty(sql)) {
			return wrappedStatement + " <-- " + CollectionUtil.toString(parameters.subList(1, parameters.size()));
		}

		String loggableStatement = this.sql; // Formated executed SQL statment suitable for logging
		int qmCounter = 1; // Question mark counter
		// TODO: Handle escaped question marks
		while (loggableStatement.indexOf('?') > -1 && qmCounter < parameters.size()) {
			String strParam = String.valueOf(parameters.get(qmCounter++));
			strParam = Matcher.quoteReplacement(strParam);
			try {
				loggableStatement = loggableStatement.replaceFirst("\\?", strParam == null ? "null" : strParam);
			} catch (Throwable t) {
				System.out.println(loggableStatement + "\t " + strParam);
				t.printStackTrace();
			}
		}

		return loggableStatement.replaceAll("\t", " ").replaceAll("  +", " ");
	}

	public void disableAutoLogging(final boolean disable) {
		this.disableLogging = disable;
	}

	protected void beforeExecution() {
		logExecution();
	}

	/**
	 * Final to ensure that exceptions get caught
	 * 
	 * @param success
	 */
	protected final void _internal_afterExecution(final boolean success) {
		try {
			afterExecution(success);
		} catch (final Throwable t) {
			// any exceptions should be handled in afterExecution method
		}
	}

	/**
	 * This method should not throw anything
	 * 
	 * @param success
	 */
	protected void afterExecution(final boolean success) {
		if (!success) {
			logError();
		}
	}

	private void logExecution() {
		if (!disableLogging) {
			StatementLoggerProvider.getLogger().logExecution(this);
		}
	}

	private void logError() {
		if (!disableLogging) {
			StatementLoggerProvider.getLogger().logExecutionError(this);
		}
	}

	private void logError(final String message) {
		if (!disableLogging) {
			StatementLoggerProvider.getLogger().logError(this, message);
		}
	}

	private void callForParam(final String paramName, final ParamSetter func) throws SQLException {
		for (int i = 0; i < parameterNames.size(); i++) {
			if (paramName.equals(parameterNames.get(i))) {
				func.setForIndex(i + 1);
			}
		}
	}

	private boolean canSetParamName() {
		return wrappedCallable != null;
	}

	@Override
	public String toString() {
		return getQueryString();
	}

	@Override
	public boolean execute() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final boolean ret = wrappedStatement.execute();
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public ResultSet executeQuery() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final ResultSet ret = wrappedStatement.executeQuery();
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int executeUpdate() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int ret = wrappedStatement.executeUpdate();
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public void addBatch() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			wrappedStatement.addBatch();
			exc = false;
		} finally {
			_internal_afterExecution(!exc);
		}

	}

	@Override
	public void addBatch(final String batchSql) throws SQLException {
		wrappedStatement.addBatch(batchSql);
	}

	@Override
	public void cancel() throws SQLException {
		wrappedStatement.cancel();
	}

	@Override
	public void clearBatch() throws SQLException {
		wrappedStatement.clearBatch();
	}

	@Override
	public void clearParameters() throws SQLException {
		wrappedStatement.clearParameters();
	}

	@Override
	public void clearWarnings() throws SQLException {
		wrappedStatement.clearWarnings();
	}

	@Override
	public void close() throws SQLException {
		boolean exc = true;
		try {
			wrappedStatement.close();
			exc = false;
			return;
		} finally {
			try {
				if (exc) {
					logError("Failed to close statement");
				}
			} catch(final Throwable t) {
				// log failed so what
			}
		}
	}

	@Override
	public boolean execute(final String execSql, final int autoGeneratedKeys) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final boolean ret = wrappedStatement.execute(execSql, autoGeneratedKeys);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public boolean execute(final String execSql, final int[] columnIndexes) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final boolean ret = wrappedStatement.execute(execSql, columnIndexes);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public boolean execute(final String execSql, final String[] columnNames) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final boolean ret = wrappedStatement.execute(execSql, columnNames);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}

	}

	@Override
	public boolean execute(final String execSql) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final boolean ret = wrappedStatement.execute(execSql);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int[] executeBatch() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int[] ret = wrappedStatement.executeBatch();
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public ResultSet executeQuery(final String execSql) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final ResultSet ret = wrappedStatement.executeQuery(execSql);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int executeUpdate(final String execSql, final int autoGeneratedKeys) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int ret = wrappedStatement.executeUpdate(execSql, autoGeneratedKeys);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int executeUpdate(final String execSql, final int[] columnIndexes) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int ret = wrappedStatement.executeUpdate(execSql, columnIndexes);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int executeUpdate(final String execSql, final String[] columnNames) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int ret = wrappedStatement.executeUpdate(execSql, columnNames);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int executeUpdate(final String execSql) throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final int ret = wrappedStatement.executeUpdate(execSql);
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public Connection getConnection() throws SQLException {
		return connection;
	}

	@Override
	public int getFetchDirection() throws SQLException {
		return wrappedStatement.getFetchDirection();
	}

	@Override
	public int getFetchSize() throws SQLException {
		return wrappedStatement.getFetchSize();
	}

	@Override
	public ResultSet getGeneratedKeys() throws SQLException {
		return wrappedStatement.getGeneratedKeys();
	}

	@Override
	public int getMaxFieldSize() throws SQLException {
		return wrappedStatement.getMaxFieldSize();
	}

	@Override
	public int getMaxRows() throws SQLException {
		return wrappedStatement.getMaxRows();
	}

	@Override
	public ResultSetMetaData getMetaData() throws SQLException {
		return wrappedStatement.getMetaData();
	}

	@Override
	public boolean getMoreResults() throws SQLException {
		return wrappedStatement.getMoreResults();
	}

	@Override
	public boolean getMoreResults(final int current) throws SQLException {
		return wrappedStatement.getMoreResults(current);
	}

	@Override
	public ParameterMetaData getParameterMetaData() throws SQLException {
		return wrappedStatement.getParameterMetaData();
	}

	@Override
	public int getQueryTimeout() throws SQLException {
		return wrappedStatement.getQueryTimeout();
	}

	@Override
	public ResultSet getResultSet() throws SQLException {
		boolean exc = true;
		try {
			beforeExecution();
			final ResultSet ret = wrappedStatement.getResultSet();
			exc = false;
			return ret;
		} finally {
			_internal_afterExecution(!exc);
		}
	}

	@Override
	public int getResultSetConcurrency() throws SQLException {
		return wrappedStatement.getResultSetConcurrency();
	}

	@Override
	public int getResultSetHoldability() throws SQLException {
		return wrappedStatement.getResultSetHoldability();
	}

	@Override
	public int getResultSetType() throws SQLException {
		return wrappedStatement.getResultSetType();
	}

	@Override
	public int getUpdateCount() throws SQLException {
		return wrappedStatement.getUpdateCount();
	}

	@Override
	public SQLWarning getWarnings() throws SQLException {
		return wrappedStatement.getWarnings();
	}

	@Override
	public void setArray(final int i, final Array x) throws SQLException {
		wrappedStatement.setArray(i, x);
		saveParamValue(i, x);
	}

	@Override
	public void setAsciiStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
		wrappedStatement.setAsciiStream(parameterIndex, x, length);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setBigDecimal(final int parameterIndex, final BigDecimal x) throws SQLException {
		wrappedStatement.setBigDecimal(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setBinaryStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
		wrappedStatement.setBinaryStream(parameterIndex, x, length);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setBlob(final int i, final Blob x) throws SQLException {
		wrappedStatement.setBlob(i, x);
		saveParamValue(i, x);
	}

	@Override
	public void setBoolean(final int parameterIndex, final boolean x) throws SQLException {
		wrappedStatement.setBoolean(parameterIndex, x);
		saveParamValue(parameterIndex, new Boolean(x));
	}

	@Override
	public void setByte(final int parameterIndex, final byte x) throws SQLException {
		wrappedStatement.setByte(parameterIndex, x);
		saveParamValue(parameterIndex, new Byte(x));
	}

	@Override
	public void setBytes(final int parameterIndex, final byte[] x) throws SQLException {
		wrappedStatement.setBytes(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setCharacterStream(final int parameterIndex, final Reader reader, final int length) throws SQLException {
		wrappedStatement.setCharacterStream(parameterIndex, reader, length);
		saveParamValue(parameterIndex, reader);
	}

	@Override
	public void setClob(final int i, final Clob x) throws SQLException {
		wrappedStatement.setClob(i, x);
		saveParamValue(i, x);
	}

	@Override
	public void setCursorName(final String name) throws SQLException {
		wrappedStatement.setCursorName(name);
	}

	@Override
	public void setDate(final int parameterIndex, final Date x, final Calendar cal) throws SQLException {
		wrappedStatement.setDate(parameterIndex, x, cal);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setDate(final int parameterIndex, final Date x) throws SQLException {
		wrappedStatement.setDate(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setDouble(final int parameterIndex, final double x) throws SQLException {
		wrappedStatement.setDouble(parameterIndex, x);
		saveParamValue(parameterIndex, new Double(x));
	}

	@Override
	public void setEscapeProcessing(final boolean enable) throws SQLException {
		wrappedStatement.setEscapeProcessing(enable);
	}

	@Override
	public void setFetchDirection(final int direction) throws SQLException {
		wrappedStatement.setFetchDirection(direction);
	}

	@Override
	public void setFetchSize(final int rows) throws SQLException {
		wrappedStatement.setFetchSize(rows);
	}

	@Override
	public void setFloat(final int parameterIndex, final float x) throws SQLException {
		wrappedStatement.setFloat(parameterIndex, x);
		saveParamValue(parameterIndex, new Float(x));
	}

	@Override
	public void setInt(final int parameterIndex, final int x) throws SQLException {
		wrappedStatement.setInt(parameterIndex, x);
		saveParamValue(parameterIndex, new Integer(x));
	}

	@Override
	public void setLong(final int parameterIndex, final long x) throws SQLException {
		wrappedStatement.setLong(parameterIndex, x);
		saveParamValue(parameterIndex, new Long(x));
	}

	@Override
	public void setMaxFieldSize(final int max) throws SQLException {
		wrappedStatement.setMaxFieldSize(max);
	}

	@Override
	public void setMaxRows(final int max) throws SQLException {
		wrappedStatement.setMaxRows(max);
	}

	@Override
	public void setNull(final int paramIndex, final int sqlType, final String typeName) throws SQLException {
		wrappedStatement.setNull(paramIndex, sqlType, typeName);
		saveParamValue(paramIndex, null);
	}

	@Override
	public void setNull(final int parameterIndex, final int sqlType) throws SQLException {
		wrappedStatement.setNull(parameterIndex, sqlType);
		saveParamValue(parameterIndex, null);
	}

	@Override
	public void setObject(final int parameterIndex, final Object x, final int targetSqlType, final int scale)
		throws SQLException {
		wrappedStatement.setObject(parameterIndex, x, targetSqlType, scale);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setObject(final int parameterIndex, final Object x, final int targetSqlType) throws SQLException {
		wrappedStatement.setObject(parameterIndex, x, targetSqlType);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setObject(final int parameterIndex, final Object x) throws SQLException {
		try {
			wrappedStatement.setObject(parameterIndex, x);
			saveParamValue(parameterIndex, x);
		} catch(SQLException e) {
			logError("Setting Object parameter failed (" + parameterIndex + ":" + x + ")");
			SQLException se = new SQLException();
			se.initCause(e);
			throw se;
		}
	}

	@Override
	public void setQueryTimeout(final int seconds) throws SQLException {
		wrappedStatement.setQueryTimeout(seconds);
	}

	@Override
	public void setRef(final int i, final Ref x) throws SQLException {
		wrappedStatement.setRef(i, x);
	}

	@Override
	public void setShort(final int parameterIndex, final short x) throws SQLException {
		wrappedStatement.setShort(parameterIndex, x);
		saveParamValue(parameterIndex, new Short(x));
	}

	@Override
	public void setString(final int parameterIndex, final String x) throws SQLException {
		wrappedStatement.setString(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setTime(final int parameterIndex, final Time x, final Calendar cal) throws SQLException {
		wrappedStatement.setTime(parameterIndex, x, cal);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setTime(final int parameterIndex, final Time x) throws SQLException {
		wrappedStatement.setTime(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x, final Calendar cal) throws SQLException {
		wrappedStatement.setTimestamp(parameterIndex, x, cal);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setTimestamp(final int parameterIndex, final Timestamp x) throws SQLException {
		wrappedStatement.setTimestamp(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	/**
	 * @deprecated
	 */
	@Deprecated
	@Override
	public void setUnicodeStream(final int parameterIndex, final InputStream x, final int length) throws SQLException {
		wrappedStatement.setUnicodeStream(parameterIndex, x, length);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public void setURL(final int parameterIndex, final URL x) throws SQLException {
		wrappedStatement.setURL(parameterIndex, x);
		saveParamValue(parameterIndex, x);
	}

	@Override
	public Array getArray(final int i) throws SQLException {
		return wrappedCallable.getArray(i);
	}

	@Override
	public Array getArray(final String parameterName) throws SQLException {
		return wrappedCallable.getArray(parameterName);
	}

	/**
	 * @deprecated
	 */
	@Deprecated
	@Override
	public BigDecimal getBigDecimal(final int parameterIndex, final int scale) throws SQLException {
		return wrappedCallable.getBigDecimal(parameterIndex, scale);
	}

	@Override
	public BigDecimal getBigDecimal(final int parameterIndex) throws SQLException {
		return wrappedCallable.getBigDecimal(parameterIndex);
	}

	@Override
	public BigDecimal getBigDecimal(final String parameterName) throws SQLException {
		return wrappedCallable.getBigDecimal(parameterName);
	}

	@Override
	public Blob getBlob(final int i) throws SQLException {
		return wrappedCallable.getBlob(i);
	}

	@Override
	public Blob getBlob(final String parameterName) throws SQLException {
		return wrappedCallable.getBlob(parameterName);
	}

	@Override
	public boolean getBoolean(final int parameterIndex) throws SQLException {
		return wrappedCallable.getBoolean(parameterIndex);
	}

	@Override
	public boolean getBoolean(final String parameterName) throws SQLException {
		return wrappedCallable.getBoolean(parameterName);
	}

	@Override
	public byte getByte(final int parameterIndex) throws SQLException {
		return wrappedCallable.getByte(parameterIndex);
	}

	@Override
	public byte getByte(final String parameterName) throws SQLException {
		return wrappedCallable.getByte(parameterName);
	}

	@Override
	public byte[] getBytes(final int parameterIndex) throws SQLException {
		return wrappedCallable.getBytes(parameterIndex);
	}

	@Override
	public byte[] getBytes(final String parameterName) throws SQLException {
		return wrappedCallable.getBytes(parameterName);
	}

	@Override
	public Clob getClob(final int i) throws SQLException {
		return wrappedCallable.getClob(i);
	}

	@Override
	public Clob getClob(final String parameterName) throws SQLException {
		return wrappedCallable.getClob(parameterName);
	}

	@Override
	public Date getDate(final int parameterIndex, final Calendar cal) throws SQLException {
		return wrappedCallable.getDate(parameterIndex, cal);
	}

	@Override
	public Date getDate(final int parameterIndex) throws SQLException {
		return wrappedCallable.getDate(parameterIndex);
	}

	@Override
	public Date getDate(final String parameterName, final Calendar cal) throws SQLException {
		return wrappedCallable.getDate(parameterName, cal);
	}

	@Override
	public Date getDate(final String parameterName) throws SQLException {
		return wrappedCallable.getDate(parameterName);
	}

	@Override
	public double getDouble(final int parameterIndex) throws SQLException {
		return wrappedCallable.getDouble(parameterIndex);
	}

	@Override
	public double getDouble(final String parameterName) throws SQLException {
		return wrappedCallable.getDouble(parameterName);
	}

	@Override
	public float getFloat(final int parameterIndex) throws SQLException {
		return wrappedCallable.getFloat(parameterIndex);
	}

	@Override
	public float getFloat(final String parameterName) throws SQLException {
		return wrappedCallable.getFloat(parameterName);
	}

	@Override
	public int getInt(final int parameterIndex) throws SQLException {
		return wrappedCallable.getInt(parameterIndex);
	}

	@Override
	public int getInt(final String parameterName) throws SQLException {
		return wrappedCallable.getInt(parameterName);
	}

	@Override
	public long getLong(final int parameterIndex) throws SQLException {
		return wrappedCallable.getLong(parameterIndex);
	}

	@Override
	public long getLong(final String parameterName) throws SQLException {
		return wrappedCallable.getLong(parameterName);
	}

	@Override
	public Object getObject(final int i, final Map<String, Class<?>> map) throws SQLException {
		return wrappedCallable.getObject(i, map);
	}

	@Override
	public Object getObject(final int parameterIndex) throws SQLException {
		return wrappedCallable.getObject(parameterIndex);
	}

	@Override
	public Object getObject(final String parameterName, final Map<String, Class<?>> map) throws SQLException {
		return wrappedCallable.getObject(parameterName, map);
	}

	@Override
	public Object getObject(final String parameterName) throws SQLException {
		return wrappedCallable.getObject(parameterName);
	}

	@Override
	public Ref getRef(final int i) throws SQLException {
		return wrappedCallable.getRef(i);
	}

	@Override
	public Ref getRef(final String parameterName) throws SQLException {
		return wrappedCallable.getRef(parameterName);
	}

	@Override
	public short getShort(final int parameterIndex) throws SQLException {
		return wrappedCallable.getShort(parameterIndex);
	}

	@Override
	public short getShort(final String parameterName) throws SQLException {
		return wrappedCallable.getShort(parameterName);
	}

	@Override
	public String getString(final int parameterIndex) throws SQLException {
		return wrappedCallable.getString(parameterIndex);
	}

	@Override
	public String getString(final String parameterName) throws SQLException {
		return wrappedCallable.getString(parameterName);
	}

	@Override
	public Time getTime(final int parameterIndex, final Calendar cal) throws SQLException {
		return wrappedCallable.getTime(parameterIndex, cal);
	}

	@Override
	public Time getTime(final int parameterIndex) throws SQLException {
		return wrappedCallable.getTime(parameterIndex);
	}

	@Override
	public Time getTime(final String parameterName, final Calendar cal) throws SQLException {
		return wrappedCallable.getTime(parameterName, cal);
	}

	@Override
	public Time getTime(final String parameterName) throws SQLException {
		return wrappedCallable.getTime(parameterName);
	}

	@Override
	public Timestamp getTimestamp(final int parameterIndex, final Calendar cal) throws SQLException {
		return wrappedCallable.getTimestamp(parameterIndex, cal);
	}

	@Override
	public Timestamp getTimestamp(final int parameterIndex) throws SQLException {
		return wrappedCallable.getTimestamp(parameterIndex);
	}

	@Override
	public Timestamp getTimestamp(final String parameterName, final Calendar cal) throws SQLException {
		return wrappedCallable.getTimestamp(parameterName, cal);
	}

	@Override
	public Timestamp getTimestamp(final String parameterName) throws SQLException {
		return wrappedCallable.getTimestamp(parameterName);
	}

	@Override
	public URL getURL(final int parameterIndex) throws SQLException {
		return wrappedCallable.getURL(parameterIndex);
	}

	@Override
	public URL getURL(final String parameterName) throws SQLException {
		return wrappedCallable.getURL(parameterName);
	}

	@Override
	public void registerOutParameter(final int parameterIndex, final int sqlType, final int scale) throws SQLException {
		saveParamValue(parameterIndex, new StringBuilder("<out type:" + SQLType.getDebugTypeString(sqlType) + " scale:"
			+ scale + ">"));
		wrappedCallable.registerOutParameter(parameterIndex, sqlType, scale);
	}

	@Override
	public void registerOutParameter(final int paramIndex, final int sqlType, final String typeName)
		throws SQLException {
		saveParamValue(paramIndex, new StringBuilder("<out type:" + SQLType.getDebugTypeString(sqlType) + " typeName:"
			+ typeName + ">"));
		wrappedCallable.registerOutParameter(paramIndex, sqlType, typeName);
	}

	@Override
	public void registerOutParameter(final int parameterIndex, final int sqlType) throws SQLException {
		saveParamValue(parameterIndex, new StringBuilder("<out " + SQLType.getDebugTypeString(sqlType) + ">"));
		wrappedCallable.registerOutParameter(parameterIndex, sqlType);
	}

	@Override
	public void registerOutParameter(final String parameterName, final int sqlType, final int scale)
		throws SQLException {
		saveParamValue(parameterName, new StringBuilder("<out " + SQLType.getDebugTypeString(sqlType) + "(" + scale
			+ ")>"));
		wrappedCallable.registerOutParameter(parameterName, sqlType, scale);
	}

	@Override
	public void registerOutParameter(final String parameterName, final int sqlType, final String typeName)
		throws SQLException {
		saveParamValue(parameterName, new StringBuilder("<out " + SQLType.getDebugTypeString(sqlType) + " T:"
			+ typeName + ">"));
		wrappedCallable.registerOutParameter(parameterName, sqlType, typeName);
	}

	@Override
	public void registerOutParameter(final String parameterName, final int sqlType) throws SQLException {
		saveParamValue(parameterName, new StringBuilder("<out " + SQLType.getDebugTypeString(sqlType) + ">"));
		wrappedCallable.registerOutParameter(parameterName, sqlType);
	}

	@Override
	public void setAsciiStream(final String parameterName, final InputStream x, final int length) throws SQLException {
		saveParamValue(parameterName, x);
		// TODO: Check if callable named parameters work
		if (canSetParamName()) {
			wrappedCallable.setAsciiStream(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setAsciiStream(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setBigDecimal(final String parameterName, final BigDecimal x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setBigDecimal(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBigDecimal(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBinaryStream(final String parameterName, final InputStream x, final int length) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setBinaryStream(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBinaryStream(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setBoolean(final String parameterName, final boolean x) throws SQLException {
		saveParamValue(parameterName, Boolean.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setBoolean(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBoolean(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setByte(final String parameterName, final byte x) throws SQLException {
		saveParamValue(parameterName, Byte.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setByte(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setByte(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBytes(final String parameterName, final byte[] x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setBytes(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBytes(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setCharacterStream(final String parameterName, final Reader reader, final int length)
		throws SQLException {
		saveParamValue(parameterName, reader);
		if (canSetParamName()) {
			wrappedCallable.setCharacterStream(parameterName, reader, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setCharacterStream(paramIndex, reader, length);

				}
			});
		}
	}

	@Override
	public void setDate(final String parameterName, final Date x, final Calendar cal) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setDate(parameterName, x, cal);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setDate(paramIndex, x, cal);

				}
			});
		}
	}

	@Override
	public void setDate(final String parameterName, final Date x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setDate(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setDate(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setDouble(final String parameterName, final double x) throws SQLException {
		saveParamValue(parameterName, Double.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setDouble(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setDouble(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setFloat(final String parameterName, final float x) throws SQLException {
		saveParamValue(parameterName, Float.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setFloat(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setFloat(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setInt(final String parameterName, final int x) throws SQLException {
		saveParamValue(parameterName, Integer.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setInt(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setInt(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setLong(final String parameterName, final long x) throws SQLException {
		saveParamValue(parameterName, Long.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setLong(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setLong(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setNull(final String parameterName, final int sqlType, final String typeName) throws SQLException {
		saveParamValue(parameterName, null);
		if (canSetParamName()) {
			wrappedCallable.setNull(parameterName, sqlType, typeName);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNull(paramIndex, sqlType, typeName);

				}
			});
		}
	}

	@Override
	public void setNull(final String parameterName, final int sqlType) throws SQLException {
		saveParamValue(parameterName, null);
		if (canSetParamName()) {
			wrappedCallable.setNull(parameterName, sqlType);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNull(paramIndex, sqlType);

				}
			});
		}
	}

	@Override
	public void setObject(final String parameterName, final Object x, final int targetSqlType, final int scale)
		throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setObject(parameterName, x, targetSqlType, scale);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setObject(paramIndex, x, targetSqlType, scale);

				}
			});
		}
	}

	@Override
	public void setObject(final String parameterName, final Object x, final int targetSqlType) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setObject(parameterName, x, targetSqlType);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setObject(paramIndex, x, targetSqlType);

				}
			});
		}
	}

	@Override
	public void setObject(final String parameterName, final Object x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setObject(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setObject(paramIndex, x);

				}
			});
		}
	}

	@Override
	public void setShort(final String parameterName, final short x) throws SQLException {
		saveParamValue(parameterName, Short.valueOf(x));
		if (canSetParamName()) {
			wrappedCallable.setShort(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setShort(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setString(final String parameterName, final String x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setString(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setString(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setTime(final String parameterName, final Time x, final Calendar cal) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setTime(parameterName, x, cal);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setTime(paramIndex, x, cal);
				}
			});
		}
	}

	@Override
	public void setTime(final String parameterName, final Time x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setTime(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setTime(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setTimestamp(final String parameterName, final Timestamp x, final Calendar cal) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setTimestamp(parameterName, x, cal);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setTimestamp(paramIndex, x, cal);
				}
			});
		}
	}

	@Override
	public void setTimestamp(final String parameterName, final Timestamp x) throws SQLException {
		saveParamValue(parameterName, x);
		if (canSetParamName()) {
			wrappedCallable.setTimestamp(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setTimestamp(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setURL(final String parameterName, final URL val) throws SQLException {
		saveParamValue(parameterName, val);
		if (canSetParamName()) {
			wrappedCallable.setURL(parameterName, val);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setURL(paramIndex, val);

				}
			});
		}
	}

	@Override
	public boolean wasNull() throws SQLException {
		return wrappedCallable.wasNull();
	}

	// //////////////////////////////////////////////////////////
	// //   JAVA 1.6 methods
	// //////////////////////////////////////////////////////////

	@Override
	public Reader getCharacterStream(int parameterIndex) throws SQLException {
		return wrappedCallable.getCharacterStream(parameterIndex);
	}

	@Override
	public Reader getCharacterStream(String parameterName) throws SQLException {
		return wrappedCallable.getCharacterStream(parameterName);
	}

	@Override
	public Reader getNCharacterStream(int parameterIndex) throws SQLException {
		return wrappedCallable.getNCharacterStream(parameterIndex);
	}

	@Override
	public Reader getNCharacterStream(String parameterName) throws SQLException {
		return wrappedCallable.getNCharacterStream(parameterName);
	}

	@Override
	public NClob getNClob(int parameterIndex) throws SQLException {
		return wrappedCallable.getNClob(parameterIndex);
	}

	@Override
	public NClob getNClob(String parameterName) throws SQLException {
		return wrappedCallable.getNClob(parameterName);
	}

	@Override
	public String getNString(int parameterIndex) throws SQLException {
		return wrappedCallable.getNString(parameterIndex);
	}

	@Override
	public String getNString(String parameterName) throws SQLException {
		return wrappedCallable.getNString(parameterName);
	}

	@Override
	public RowId getRowId(int parameterIndex) throws SQLException {
		return wrappedCallable.getRowId(parameterIndex);
	}

	@Override
	public RowId getRowId(String parameterName) throws SQLException {
		return wrappedCallable.getRowId(parameterName);
	}

	@Override
	public SQLXML getSQLXML(int parameterIndex) throws SQLException {
		return wrappedCallable.getSQLXML(parameterIndex);
	}

	@Override
	public SQLXML getSQLXML(String parameterName) throws SQLException {
		return wrappedCallable.getSQLXML(parameterName);
	}

	@Override
	public void setAsciiStream(String parameterName, final InputStream x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setAsciiStream(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setAsciiStream(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setAsciiStream(String parameterName, final InputStream x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setAsciiStream(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setAsciiStream(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setBinaryStream(String parameterName, final InputStream x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setBinaryStream(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBinaryStream(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBinaryStream(String parameterName, final InputStream x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setBinaryStream(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBinaryStream(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBlob(String parameterName, final Blob x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setBlob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBlob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBlob(String parameterName, final InputStream x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setBlob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBlob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setBlob(String parameterName, final InputStream x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setBlob(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setBlob(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setCharacterStream(String parameterName, final Reader x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setCharacterStream(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setCharacterStream(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setCharacterStream(String parameterName, final Reader x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setCharacterStream(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setCharacterStream(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setClob(String parameterName, final Clob x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setClob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setClob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setClob(String parameterName, final Reader x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setClob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setClob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setClob(String parameterName, final Reader x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setClob(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setClob(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setNCharacterStream(String parameterName, final Reader x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNCharacterStream(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNCharacterStream(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setNCharacterStream(String parameterName, final Reader x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNCharacterStream(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNCharacterStream(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setNClob(String parameterName, final NClob x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNClob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNClob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setNClob(String parameterName, final Reader x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNClob(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNClob(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setNClob(String parameterName, final Reader x, final long length) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNClob(parameterName, x, length);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNClob(paramIndex, x, length);
				}
			});
		}
	}

	@Override
	public void setNString(String parameterName, final String x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setNString(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setNString(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setRowId(String parameterName, final RowId x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setRowId(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setRowId(paramIndex, x);
				}
			});
		}
	}

	@Override
	public void setSQLXML(String parameterName, final SQLXML x) throws SQLException {
		if (canSetParamName()) {
			wrappedCallable.setSQLXML(parameterName, x);
		} else {
			callForParam(parameterName, new ParamSetter() {
				@Override
				public void setForIndex(int paramIndex) throws SQLException {
					wrappedStatement.setSQLXML(paramIndex, x);
				}
			});
		}
	}

	@Override
	public boolean isClosed() throws SQLException {
		return wrappedStatement.isClosed();
	}

	@Override
	public boolean isPoolable() throws SQLException {
		return wrappedStatement.isPoolable();
	}

	@Override
	public void setPoolable(boolean poolable) throws SQLException {
		wrappedStatement.setPoolable(poolable);
	}


	@Override
	public void setAsciiStream(int parameterIndex, InputStream x, long length) throws SQLException {
		wrappedStatement.setAsciiStream(parameterIndex, x, length);
	}

	@Override
	public void setAsciiStream(int parameterIndex, InputStream x) throws SQLException {
		wrappedStatement.setAsciiStream(parameterIndex, x);
	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x, long length) throws SQLException {
		wrappedStatement.setBinaryStream(parameterIndex, x, length);
	}

	@Override
	public void setBinaryStream(int parameterIndex, InputStream x) throws SQLException {
		wrappedStatement.setBinaryStream(parameterIndex, x);
	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream, long length) throws SQLException {
		wrappedStatement.setBlob(parameterIndex, inputStream, length);
	}

	@Override
	public void setBlob(int parameterIndex, InputStream inputStream) throws SQLException {
		wrappedStatement.setBlob(parameterIndex, inputStream);
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader, long length) throws SQLException {
		wrappedStatement.setCharacterStream(parameterIndex, reader, length);
	}

	@Override
	public void setCharacterStream(int parameterIndex, Reader reader) throws SQLException {
		wrappedStatement.setCharacterStream(parameterIndex, reader);
	}

	@Override
	public void setClob(int parameterIndex, Reader reader, long length) throws SQLException {
		wrappedStatement.setClob(parameterIndex, reader, length);
	}

	@Override
	public void setClob(int parameterIndex, Reader reader) throws SQLException {
		wrappedStatement.setClob(parameterIndex, reader);
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value, long length) throws SQLException {
		wrappedStatement.setNCharacterStream(parameterIndex, value, length);
	}

	@Override
	public void setNCharacterStream(int parameterIndex, Reader value) throws SQLException {
		wrappedStatement.setNCharacterStream(parameterIndex, value);
	}

	@Override
	public void setNClob(int parameterIndex, NClob value) throws SQLException {
		wrappedStatement.setNClob(parameterIndex, value);
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader, long length) throws SQLException {
		wrappedStatement.setNClob(parameterIndex, reader, length);
	}

	@Override
	public void setNClob(int parameterIndex, Reader reader) throws SQLException {
		wrappedStatement.setNClob(parameterIndex, reader);
	}

	@Override
	public void setNString(int parameterIndex, String value) throws SQLException {
		wrappedStatement.setNString(parameterIndex, value);
	}

	@Override
	public void setRowId(int parameterIndex, RowId x) throws SQLException {
		wrappedStatement.setRowId(parameterIndex, x);
	}

	@Override
	public void setSQLXML(int parameterIndex, SQLXML xmlObject) throws SQLException {
		wrappedStatement.setSQLXML(parameterIndex, xmlObject);
	}

	@Override
	@SuppressWarnings("unchecked")
	public <T> T unwrap(Class<T> iface) throws SQLException {
		if (iface.isInstance(this)) {
			return (T)this;
		}
		if (wrappedStatement == null) {
			throw new SQLException("Not implenting or wrapping " + iface);
		}
		return wrappedStatement.unwrap(iface);
	}

	@Override
	public boolean isWrapperFor(Class<?> iface) throws SQLException {
		if (iface.isInstance(this)) {
			return true;
		}
		return wrappedStatement == null ? false : wrappedStatement.isWrapperFor(iface);
	}
	
}
